# 명세
'평범한 한글' 프로그램은 한글과 그 외 문자로 이루어진 문자열입니다.
여기서 한글은 다음의 범위에 들어가는 유니코드 문자를 말합니다.

* U+1100-U+11FF (한글 자모)
* U+302E-U+302F (방점)
* U+3131-U+318E (호환용 한글 자모)
* U+A960-U+A97C (한글 자모 확장 A)
* U+AC00-U+D7AF (한글 음절)
* U+D7B0-U+D7C6, U+D7CB-U+D7FB (한글 자모 확장 B)
* U+FFA1-U+FFBE, U+FFC2-U+FFC7, U+FFCA-U+FFCF, U+FFD2-U+FFD7, U+FFDA-U+FFDC (반각 한글 자모)

한글은 다시 초성(호환용 한글 자모와 반각 한글 자모는 자음) 및 그 외 한글로 구분해, 초성이 아닌 한글은 삭제하고 초성은 해당하는 호환용 한글 자모로 변환합니다. 한글 음절은 초성만 추출하여 변환합니다. 편의를 위해 본 명세에서 한글은 호환용 한글 자모 중 자음이 대표합니다. 변환 예시는 다음과 같습니다.

* `동해물과 백두산이` = `ㄷㅎㅁㄱ ㅂㄷㅅㅇ`
* `나랏〮말〯ᄊᆞ미〮 듕귁〮에〮달아〮` = `ㄴㄹㅁㅆㅁ ㄷㄱㅇㄷㅇ`

한편 한글이 아닌 문자는 달리 구분하지 않고 공백과 같이 생각합니다. 따라서 본 명세에도 한글이 아닌 문자는 공백이 대표합니다.

거센소리와 된소리는 예사소리와 같게 취급하며, 겹자음은 자음 여러 개로 분리하여 생각합니다. 이는 작문 시 단어 선택의 폭을 넓히기 위한 선택입니다. 예시로, 다음 단어쌍들은 동일합니다.

* `ㄱㄲㅅㄹ` = `ㄱㄱㅅㄹ`
* `ㅇㅊㅂㅌ` = `ㅇㅈㅂㄷ`
* `ㄳㅎㄴㄷ` = `ㄱㅅㅎㄴㄷ`

간결한 설명을 위해 예사소리 단자음 10개 `ㄱㄴㄷㄹㅁㅂㅅㅇㅈㅎ`만 사용하여 설명하겠습니다. 또한, 모든 `ㅇ`과 `ㅎ`은 그 앞에 공백이 있는 것과 없는 것을 같게 봅니다. 따라서 편의를 위해 모든 `ㅇ`과 `ㅎ` 앞에 미리 공백을 추가했다고 가정하겠습니다.

## 가. 정수 리터럴
`ㅇ`과 `ㅎ`을 제외한 8개 자음 `ㄱㄴㄷㄹㅁㅂㅅㅈ`은 8진수 가변 길이 정수를 부호화하기 위한 목적으로**만** 사용됩니다.

* 자음 `ㄱ, ㄴ, ㄷ, ㄹ, ㅁ, ㅂ, ㅅ, ㅈ`은 각각 8진수 숫자 0, 1, 2, 3, 4, 5, 6, 7을 뜻합니다.
* 가장 낮은 자리수가 가장 먼저 옵니다. 즉, 역순으로 부호화합니다. 예를 들어, 8진수 210은 `ㄱㄴㄷ`로 적습니다.
* 자음 개수가 홀수면 양수를, 자음 개수가 짝수면 음수를 뜻합니다. 뒤에 `ㄱ`(0)을 덧붙이는 방법으로 원하는 부호를 지정할 수 있습니다.

예시는 다음과 같습니다.

* `ㄱ` (oct +0) = 0
* `ㄴ` (oct +1) = 1
* `ㄴㄱ` (oct -01) = -1
* `ㄴㄱㄱ` (oct +001) = 1
* `ㄱㄴ` (oct -10) = -8
* `ㄱㄴㄱ` (oct +010) = +8
* `ㄱㄱㄴ` (oct +100) = +64
* `ㄱㄱㄴㄱ` (oct -0100) = -64

## 나. 단어
단어란 공백을 포함하지 않는 가장 긴 연속한 한글열을 말합니다. 예를 들어 프로그램 `ㄱ ㄴㄷ   ㄱ ㅎㄷ`은 단어 네 개 `ㄱ`, `ㄴㄷ`, `ㄱ`, `ㅎㄷ`으로 이루어져 있습니다.

## 다. 객체와 자료형
객체는 프로그램 실행의 기본 단위입니다. 객체는 `ㄱㄴㄷㄹㅁㅂㅅㅈ`으로만 단어를 구성한 정수 리터럴이거나, 함수 만들기 혹은 함수 호출로 만들어진 것이며, 함수의 인수로 사용할 수 있습니다. 객체의 자료형은 기본 자료형과 이를 바탕으로 만드는 사용자 정의 자료형이 있으며, 기본 자료형은 다음 열한 가지입니다.
* 정수(Integer)
* 실수(Float)
* 복소수(Complex)
* 논릿값(Boolean)
* 문자열(String)
* 바이트열(Bytes)
* 목록(List)
* 사전(Dict)
* 함수(Function)
* 드나듦(IO)
* 빈값(Nil)

사용자 정의 자료형은 [자. 사용자 정의 자료형](#자-사용자-정의-자료형)에서 설명하겠습니다.

## 라. 함수
### 만들기
모든 함수는 0개 이상의 객체를 인수로 받아 객체 하나를 돌려줍니다. 함수를 만들 때 인수를 몇 개 받을지는 따로 표기하지 않습니다. 함수를 만드는 표현식은 다음과 같이 함수 몸통이 되는 객체 하나와 단어 `ㅎ`으로 이루어지며, 표현식 전체가 함수 객체가 됩니다.

`[함수 몸통] ㅎ`

예를 들어 인수에 상관 없이 정수 3을 돌려주는 함수는 `ㄹ ㅎ`으로 만듭니다.

### 함수 호출
인수 n개를 써서 함수를 호출하는 표현식은 다음과 같이, (n+1)개의 객체에 이어 `ㅎ` 뒤에 인수 개수 n을 부호화한 정수 리터럴을 붙인 단어 1개로 구성됩니다. 마지막 객체가 호출할 함수이고, 첫 n개의 객체가 이 함수에 인수로 전달됩니다.

`[인수0] [인수1] [인수2] ... [인수n-1] [함수] ㅎ[정수 리터럴 n]`

인수에 상관 없이 정수 3을 돌려주는 함수에 두 개의 인수 1과 -1을 전달하여 부르는 표현식은 다음과 같습니다.

`ㄴ ㄴㄱ ㄹ ㅎ ㅎㄷ`

### 기본 제공 함수
본래 호출할 함수는 함수 객체여야 하지만, 정수 리터럴에 한해 정수 객체를 허용하며, 복소수, 논릿값, 사전, 목록, 문자열 및 바이트열 객체도 허용합니다. 자세한 내용은 [기본 제공 함수](builtins.md) 문서를 참조해주세요.

### 재귀 함수
함수를 만들 때 만들려는 함수와 둘러싼 함수를 함수 몸통에서 쓸 수 있습니다. 만들려는 함수를 0번째라고 하고, k번째 함수를 바로 둘러싼 함수를 (k+1)번째라고 합시다. m번째 함수를 쓰려면 다음과 같이 합니다.

`[정수 리터럴 m] ㅇ`

예를 들어 1번째 함수를 쓰려면 다음과 같이 합니다.

`ㄴ ㅇ`

m이 음수인 경우 바깥쪽에서 (-m-1)번째 함수를 씁니다. 참고로 이 번호는 함수 객체 안에 저장되어 함수 객체를 어느 문맥에서 부르더라도 일관된 행동을 보장합니다.

## 마. 인수
### 인수 가져오기
함수를 만들 때 만들려는 함수와 둘러싼 함수에 전달되는 인수를 사용할 수 있습니다. 앞서와 같이 함수에 번호를 매겨서, m번째 함수의 n번째 인수를 가져오는 표현식은 다음과 같습니다. m이 음수인 경우 바깥쪽에서 (-m-1)번째 함수의 n번째 인수를 가져옵니다. 다만 n이 음수인 경우는 금지됩니다.

`[정수 리터럴 n] ㅇ[정수 리터럴 m]`

예를 들어 자기가 받은 0번째 인수를 내놓는 함수는 다음과 같습니다.

`ㄱ ㅇㄱ ㅎ`

또, 자기가 받은 0번째 인수와 1번째 인수를 더해 내놓는 함수는 다음과 같습니다.

`ㄱ ㅇㄱ ㄴ ㅇㄱ ㄷ ㅎㄷ ㅎ`

한편 함수 λx.λy.(x+y)는 다음과 같이 작성할 수 있습니다.

`ㄱ ㅇㄴ ㄱ ㅇㄱ ㄷ ㅎㄷ ㅎ ㅎ`

이 함수에 차례로 3과 4를 인수로 넣어 호출하는 표현식은 다음과 같습니다.

`ㄹ ㅁ ㄱ ㅇㄴ ㄱ ㅇㄱ ㄷ ㅎㄷ ㅎ ㅎ ㅎㄴ ㅎㄴ`

### 동적으로 가져오기
몇 번째 인수를 가져올지 미리 정해지지 않으면 동적으로 값을 평가해 그 값으로 가져올 수 있습니다. 다음과 같이 정수 객체 하나와 `ㅇ`으로 시작하는 단어 하나로 이뤄진 표현식을 생각합시다. 정수 객체의 값이 n이면, 다음 표현식은 m번째 함수의 n번째 인수를 가져옵니다.

`[정수 객체 n] ㅇ[정수 리터럴 m]`

예를 들어 `ㄱ ㅇㄱ ㅇㄱ ㅎ`은 다음 의사 코드로 표현할 수 있습니다.

```python
def func(*argv):
  return argv[argv[0]]
```

또 `ㄱ ㅇㄱ ㄴ ㄷ ㅎㄷ ㅇㄱ ㅎ`은 다음 의사 코드로 표현할 수 있습니다.

```python
def func(*argv):
  return argv[argv[0] + 1]
```

## 바. 드나듦(IO)
'평범한 한글'의 드나듦 객체는 하스켈의 IO 모나드(Monad)에서 따왔습니다. 이것은 부작용이 있는 연산을 격리하고 실행 순서를 명확하게 하기 위한 목적입니다. 이를 위해 입력받은 값을 바로 활용하는 것은 금지되고, 대신 그 값을 어떻게 활용할지를 미리 계획합니다. 표현식을 전부 평가했을 때 드나듦 객체가 나오면, 인터프리터는 그때부터 드나듦 객체에 적힌 계획에 따라 입출력 연산을 실행하게 됩니다.

먼저, 기본 제공 함수 `ㄹ`을 부르면 표준 입력에서 문자열을 받아오는 계획이 담긴 드나듦 객체를 얻습니다. 이것과 함께 나중에 그 값으로 무엇을 할지 계획한 함수로 기본 제공 함수 `ㄱㄹ`을 불러 새 드나듦 객체를 만듭니다. 이때 마지막 인수인 함수는 드나듦 객체를 내놓아야 합니다.

예를 들어, 표준 입력에서 문자열을 받아 그대로 표준 출력으로 보내는 계획을 담은 드나듦 객체는 다음과 같습니다.

`ㄹ ㅎㄱ ㄱ ㅇㄱ ㅈㄹ ㅎㄴ ㅎ ㄱㄹ ㅎㄷ`

여기서 `ㄹ ㅎㄱ`은 앞서 언급했듯 문자열을 입력받는 계획이 담긴 드나듦 객체입니다. 한편 `ㅈㄹ ㅎㄴ`은 인수를 출력하는 계획이 담긴 드나듦 객체입니다. 따라서 `ㄱ ㅇㄱ ㅈㄹ ㅎㄴ ㅎ`은 인수를 받아서 그것을 출력할 드나듦 객체를 만드는 함수입니다. 기본 제공 함수 `ㄱㄹ`은 드나듦 객체와 드나듦 객체를 만들 함수를 하나씩 인수로 받아 새 드나듦 객체를 만듭니다. 인터프리터는 이 드나듦 객체를 만나면 첫번째 인수를 실행해 값을 얻고, 이것으로 두번째 인수를 부릅니다. 그 결과로 인터프리터는 표준 출력을 하는 드나듦 객체를 만나, 출력을 수행하고 끝냅니다.

다른 예로, 입력값을 받아 실수로 변환하는 프로그램은 다음과 같습니다. 여기서 기본 제공 함수 `ㄱㅅ`은 나중에 실행되면 인수로 받은 값을 그대로 돌려주는 드나듦을 만듭니다.

`ㄹ ㅎㄱ ㅅㅅ ㄱㅅ ㄴㄱㅎㄷ ㄱㄹ ㅎㄷ`

여기서 함수 `ㅅㅅ ㄱㅅ ㄴㄱㅎㄷ`은 문자열을 실수로 변환해 드나듦 객체로 감싸 내놓는 함수입니다. 기본 제공 함수 `ㄱㄹ`은 `ㄹ`을 불러서 받은 드나듦 객체와 이 함수를 묶어 새 드나듦 객체를 만듭니다. 이후에 이 드나듦 객체가 실행되면 먼저 드나듦 `ㄹ ㅎㄱ`을 실행해 값을 받은 후 이것을 인수로 위 함수를 불러 최종 드나듦을 받게 됩니다. 이것까지 실행하면 원하는 실수값이 나옵니다.

이것을 응용하여 입력값을 두 개 받아 거듭제곱을 출력하는 프로그램을 다음과 같이 짤 수 있습니다.

`ㄹ ㅎㄱ ㅅㅅ ㄱㅅ ㄴㄱㅎㄷ ㄱㄹ ㅎㄷ ㄱ ㅇㄱ ㄱ ㅇㄱ ㅅ ㅁㅈ ㅈㄹ ㄴㄱ ㅎㄹ ㄱㄹ ㅎㄹ ㅎ ㅎㄴ`

여기서 `ㅅ ㅁㅈ ㅈㄹ ㄴㄱ ㅎㄹ`은 받은 인수로 계산한 거듭제곱을 문자열로 바꿔 출력하는 드나듦 객체를 만드는 함수입니다. 기본 제공 함수 `ㄱㄹ`은 앞서 입력값을 받아 실수로 변환하는 드나듦 객체 두 개와 이 함수를 묶어 우리가 원하는 드나듦 객체를 만들어 줍니다.